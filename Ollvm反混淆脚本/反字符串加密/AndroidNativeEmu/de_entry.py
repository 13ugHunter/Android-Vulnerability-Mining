import logging
import sys

from unicorn import *
import struct

from androidemu.emulator import Emulator

logging.basicConfig( # 设置日志
    stream=sys.stdout,
    level=logging.DEBUG,
    format='%(asctime)s %(levelname)7s %(name)34s | %(message)s'
)
logger = logging.getLogger(__name__)
emulator = Emulator(vfp_inst_set=True, vfs_root='vfs') # 创建模拟器
str_datas = {}
def hook_mem_write(uc,type,address,size,value,userdata): # 当发生写内存操作时进行Hook
    try:
        curdata = struct.pack("I", value)[:size]
        str_datas[address] = curdata
    except:
        print(size)


emulator.mu.hook_add(UC_HOOK_MEM_WRITE,hook_mem_write) # 添加Hook，需在加载so前

#emulator.load_library('libc.so',do_init=False) # 补充加载libc.so，不然可能会有问题

lib_module = emulator.load_library('obf.so',do_init=True)


base_addr = lib_module.base
sodata = open('obf.so', 'rb').read()
for address,value in str_datas.items():
    if base_addr < address < base_addr + lib_module.size: # 判断是否是我们需要的so文件内存空间
        offset = address - base_addr -0x1000 # 加载的基址还多了个0x1000
        print('address:0x%x data:%s offset:0x%x ' % (address, value, offset+0x1000))
        sodata = sodata[:(offset)] + value + sodata[offset+len(value):] # 将解密后的字符串写回
#print("sodata"+str(sodata[:0x3810]))

with open('obf_new.so','wb') as file:
    file.write(sodata)
file.close()